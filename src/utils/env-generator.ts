// .env file generation utilities (ScaleTail style with comments)

import type { ServiceConfig } from "../types/compose";

export interface EnvVariable {
  key: string;
  value: string;
  comment?: string;
  required?: boolean;
}

/**
 * Generate .env file content with comments (ScaleTail style)
 */
export function generateEnvFile(
  services: ServiceConfig[],
  vpnConfig?: any
): string {
  const lines: string[] = [];
  
  // Header comment
  lines.push("# .env file generated by Dock-Dploy");
  lines.push("# Make sure you have updated/checked the .env file with the correct variables.");
  lines.push("# All the ${ xx } need to be defined here.");
  lines.push("");

  // Service environment variables
  const envVars = new Map<string, EnvVariable>();
  
  services.forEach((service) => {
    service.environment.forEach((env) => {
      if (env.key && !envVars.has(env.key)) {
        envVars.set(env.key, {
          key: env.key,
          value: env.value || "",
          comment: `Used by service: ${service.name}`,
        });
      }
    });
  });

  if (envVars.size > 0) {
    lines.push("# Service Environment Variables");
    envVars.forEach((envVar) => {
      if (envVar.comment) {
        lines.push(`# ${envVar.comment}`);
      }
      // Check if value is a template variable reference
      const isTemplateVar = envVar.value.startsWith("${") && envVar.value.endsWith("}");
      if (isTemplateVar) {
        lines.push(`${envVar.key}=${envVar.value}`);
      } else {
        lines.push(`${envVar.key}=${envVar.value || ""}`);
      }
    });
    lines.push("");
  }

  // VPN-specific variables
  if (vpnConfig && vpnConfig.enabled) {
    lines.push("# VPN Configuration Variables");
    
    if (vpnConfig.type === "tailscale" && vpnConfig.tailscale) {
      const ts = vpnConfig.tailscale;
      if (ts.authKey) {
        lines.push("# Tailscale auth key - get from https://login.tailscale.com/admin/settings/keys");
        lines.push("TS_AUTHKEY=");
      }
      if (ts.hostname) {
        lines.push(`# Tailscale hostname for this device`);
        lines.push(`TS_HOSTNAME=${ts.hostname}`);
      }
    } else if (vpnConfig.type === "newt" && vpnConfig.newt) {
      const newt = vpnConfig.newt;
      if (newt.newtId) {
        lines.push("# Newt ID from Pangolin");
        lines.push("NEWT_ID=");
      }
      if (newt.newtSecret) {
        lines.push("# Newt Secret from Pangolin");
        lines.push("NEWT_SECRET=");
      }
    } else if (vpnConfig.type === "cloudflared" && vpnConfig.cloudflared) {
      if (vpnConfig.cloudflared.tunnelToken) {
        lines.push("# Cloudflare Tunnel Token");
        lines.push("TUNNEL_TOKEN=");
      }
    } else if (vpnConfig.type === "zerotier" && vpnConfig.zerotier) {
      if (vpnConfig.zerotier.networkId) {
        lines.push("# ZeroTier Network ID");
        lines.push("ZT_NETWORK_ID=");
      }
    } else if (vpnConfig.type === "netbird" && vpnConfig.netbird) {
      if (vpnConfig.netbird.setupKey) {
        lines.push("# Netbird Setup Key");
        lines.push("NETBIRD_SETUP_KEY=");
      }
    }
    lines.push("");
  }

  // Common service variables
  const commonVars: EnvVariable[] = [
    { key: "SERVICE", value: "", comment: "Service name - used for container naming" },
    { key: "IMAGE_URL", value: "", comment: "Docker image URL" },
    { key: "SERVICEPORT", value: "", comment: "Service port number" },
    { key: "DNS_SERVER", value: "9.9.9.9", comment: "DNS server (optional, uncomment if needed)" },
  ];

  const hasCommonVars = services.some((s) => 
    s.environment.some((e) => 
      commonVars.some((cv) => e.key === cv.key)
    )
  );

  if (hasCommonVars) {
    lines.push("# Common Variables");
    commonVars.forEach((cv) => {
      if (cv.comment) {
        lines.push(`# ${cv.comment}`);
      }
      lines.push(`${cv.key}=${cv.value || ""}`);
    });
  }

  return lines.join("\n");
}

/**
 * Extract environment variables from services for .env file
 */
export function extractEnvVariables(services: ServiceConfig[]): EnvVariable[] {
  const envVars = new Map<string, EnvVariable>();
  
  services.forEach((service) => {
    service.environment.forEach((env) => {
      if (env.key && !envVars.has(env.key)) {
        envVars.set(env.key, {
          key: env.key,
          value: env.value || "",
          comment: `Used by service: ${service.name}`,
        });
      }
    });
  });

  return Array.from(envVars.values());
}

